This document is meant to give insight into my thinking before starting on the problem.

Helpfully, the challenge provides a number of features in the form of stories.

Reading those features, I can see that the vending machine's interface is getting defined. 

INPUT: coins, button presses, data on internal inventory, data on internal change-making abilities
OUTPUT: coins, display, vended items

Interestingly there is no requirement to allow paper bills or credit cards to be used for payment. 

Organizing this project, I can see that there might be a need for supporting services, such as an inventory service to manage the actual inventory of the machine and ...what do I call it? A bank? I'm going to call it a bank, which manages the ability to provide change.

I recall learning a long time ago (high school?) that the coins you put into the machine are not the same coins used to make change, so there would need to be a separate storage area for the bank's change and presumably a controller to let the main system know how much change was still available. The money used to pay for the snacks would go into a coin box as an input only. Perhaps a future feature would be to indicate that the machine can't be used because the coin box is full.

There would need to be a way to keep the entered coins until either a successful selection is made or the coins are returned. Doing some research, there's some fun hardware that determines if a coins is a quarter, nickel, dime, or invalid (penny or fake), so the software will probably need to interface with that hardware through an API. 

-------------------------------------------------------------------------------
Let's start with the first feature, Accept Coins.

After some sketching, I decided to start creating a CoinValidator class. It will interface with the hardware through an API to let it know when a coin has been added and what kind. It will decide if it should keep the coins and if it should reject them. And it should keep a running total of the money used. Internally, however, it should probably keep an array of the coins, so it knows what to release back to the user later. 

Actually, is it necessary? The hardware knows what coins are what. This code should just need to accept that there are real coins out in the real world and that they are being handled.

Except the story's explanation indicates that my code is what needs to determine if something is valid. That is, apparently this code is in the controller and is doing the checks.

Ok, so then the validator needs to be queried: given a coin with such and such characteristics, should I reject it or keep it?

Actually, now I see that there is a validator (reject/keep decision) and an identifier (which coin is it). 

The identifier should be given a weight and a size. Ultimately it would be nice to have these pieces of data provided in a file so it is easy to update the vending machine with new valid coin types, such as when the mint decides to offer special kinds of coins. What if the buffalo nickel is reintroduced? In the meantime, I am going to look up the weights of the coins and hardcode them in. Oh, hey, https://www.usmint.gov/learn/coin-and-medal-programs/coin-specifications is handy.

I realize the size isn't in one dimension. There is the diameter of the coin as well as the thickness of the coin. 

And I know from experience that using ints is better than using floats, even if floats are an intuitive choice. Checking equality of floats is awkward, and so the ints will need to be multiplied in a standard way. So, if a quarter is 5.670 grams, it can be represented as 5670. 

The story mentions only weight and size, although real vending machines also use electromagnets to identify the metal types. While I won't work on it, I can imagine such a feature being needed in the future. So, I'm thinking about the open-closed principle and wondering if there is a way to design my identifier to take a collection of objects that each consider some criteria about the coin in question and then queries each object to determine what they all think it is. So, a WeightIdentifier and a SizeIdentifier today, but tomorrow there might be a MetalContentIdentifier. If they all agree, then it is the coin they all say it is, but if they don't agree, it's an invalid coin. Maybe it is overkill to design it that way now, but it's good to keep in mind, and it should be easy to refactor to such a solution later.

Instead of coin validator, I've decided to call it a coin accepter. 

My next test needed a way to add a coin, and I deciced to create a data structure for it. Which drove the need for a CoinCandidate struct. And like my Cents typedef, I am thinking that it might make sense to create typedefs for the weight, diameter, and thickness. I'll worry about refactoring once this test passes, although I already refactored to move the weight, diameter, and thickness enums into their own header so I can use them directly in this test.

For this test, I'm making it pass in the simplest way possible, as per TDD As If You Mean It. I find it is helpful to test-drive in this way, instead of assuming my higher-level design is accurate. Sometimes, I find that a completely different approach appears and works pretty well if I let the tests drive the design like they are supposed to. 

Ultimately, my coin accepter should use the coin identifier to recognize the different coins. My inclination would be to mock out the identifier, inject it into accepter's constructor, and ensure that each class is tested independently. On the other hand, the behavior of the accepter shouldn't rely on implementation details (which are already tested in its own class). The benefit of the former is that if something is broken, the tests will tell me exactly where it went wrong, whereas the advantage of the latter is that it should result in less brittle code. It feels awkward to have two separate unit tests for two separate classes that say "given these quarter characteristics, ensure that it thinks it is a quarter", but they are operating on two different concepts. One is about the coin itself, and the other is about the result of knowing it is a specific coin. 

Now we're using the identifier, but the values are hardcoded. I can already see replacing my switch statement with a map, and providing constants for the Cents. And eventually I would like to be able to keep a collection of CoinTypes, but they aren't really needed until the story Return Coins. Until then, a running total works just fine.
