This document is meant to give insight into my thinking before starting on the problem.

Helpfully, the challenge provides a number of features in the form of stories.

Reading those features, I can see that the vending machine's interface is getting defined. 

INPUT: coins, button presses, data on internal inventory, data on internal change-making abilities
OUTPUT: coins, display, vended items

Interestingly there is no requirement to allow paper bills or credit cards to be used for payment. 

Organizing this project, I can see that there might be a need for supporting services, such as an inventory service to manage the actual inventory of the machine and ...what do I call it? A bank? I'm going to call it a bank, which manages the ability to provide change.

I recall learning a long time ago (high school?) that the coins you put into the machine are not the same coins used to make change, so there would need to be a separate storage area for the bank's change and presumably a controller to let the main system know how much change was still available. The money used to pay for the snacks would go into a coin box as an input only. Perhaps a future feature would be to indicate that the machine can't be used because the coin box is full.

There would need to be a way to keep the entered coins until either a successful selection is made or the coins are returned. Doing some research, there's some fun hardware that determines if a coins is a quarter, nickel, dime, or invalid (penny or fake), so the software will probably need to interface with that hardware through an API. 

-------------------------------------------------------------------------------
Let's start with the first feature, Accept Coins.

After some sketching, I decided to start creating a CoinValidator class. It will interface with the hardware through an API to let it know when a coin has been added and what kind. It will decide if it should keep the coins and if it should reject them. And it should keep a running total of the money used. Internally, however, it should probably keep an array of the coins, so it knows what to release back to the user later. 

Actually, is it necessary? The hardware knows what coins are what. This code should just need to accept that there are real coins out in the real world and that they are being handled.

Except the story's explanation indicates that my code is what needs to determine if something is valid. That is, apparently this code is in the controller and is doing the checks.

Ok, so then the validator needs to be queried: given a coin with such and such characteristics, should I reject it or keep it?

Actually, now I see that there is a validator (reject/keep decision) and an identifier (which coin is it). 

The identifier should be given a weight and a size. Ultimately it would be nice to have these pieces of data provided in a file so it is easy to update the vending machine with new valid coin types, such as when the mint decides to offer special kinds of coins. What if the buffalo nickel is reintroduced? In the meantime, I am going to look up the weights of the coins and hardcode them in. Oh, hey, https://www.usmint.gov/learn/coin-and-medal-programs/coin-specifications is handy.

I realize the size isn't in one dimension. There is the diameter of the coin as well as the thickness of the coin. 

And I know from experience that using ints is better than using floats, even if floats are an intuitive choice. Checking equality of floats is awkward, and so the ints will need to be multiplied in a standard way. So, if a quarter is 5.670 grams, it can be represented as 5670. 

The story mentions only weight and size, although real vending machines also use electromagnets to identify the metal types. While I won't work on it, I can imagine such a feature being needed in the future. So, I'm thinking about the open-closed principle and wondering if there is a way to design my identifier to take a collection of objects that each consider some criteria about the coin in question and then queries each object to determine what they all think it is. So, a WeightIdentifier and a SizeIdentifier today, but tomorrow there might be a MetalContentIdentifier. If they all agree, then it is the coin they all say it is, but if they don't agree, it's an invalid coin. Maybe it is overkill to design it that way now, but it's good to keep in mind, and it should be easy to refactor to such a solution later.

Instead of coin validator, I've decided to call it a coin accepter. 
