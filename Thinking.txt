This document is meant to give insight into my thinking before starting on the problem.

Helpfully, the challenge provides a number of features in the form of stories.

Reading those features, I can see that the vending machine's interface is getting defined. 

INPUT: coins, button presses, data on internal inventory, data on internal change-making abilities
OUTPUT: coins, display, vended items

Interestingly there is no requirement to allow paper bills or credit cards to be used for payment. 

Organizing this project, I can see that there might be a need for supporting services, such as an inventory service to manage the actual inventory of the machine and ...what do I call it? A bank? I'm going to call it a bank, which manages the ability to provide change.

I recall learning a long time ago (high school?) that the coins you put into the machine are not the same coins used to make change, so there would need to be a separate storage area for the bank's change and presumably a controller to let the main system know how much change was still available. The money used to pay for the snacks would go into a coin box as an input only. Perhaps a future feature would be to indicate that the machine can't be used because the coin box is full.

There would need to be a way to keep the entered coins until either a successful selection is made or the coins are returned. Doing some research, there's some fun hardware that determines if a coins is a quarter, nickel, dime, or invalid (penny or fake), so the software will probably need to interface with that hardware through an API. 

-------------------------------------------------------------------------------
Let's start with the first feature, Accept Coins.

After some sketching, I decided to start creating a CoinValidator class. It will interface with the hardware through an API to let it know when a coin has been added and what kind. It will decide if it should keep the coins and if it should reject them. And it should keep a running total of the money used. Internally, however, it should probably keep an array of the coins, so it knows what to release back to the user later. 

Actually, is it necessary? The hardware knows what coins are what. This code should just need to accept that there are real coins out in the real world and that they are being handled.

Except the story's explanation indicates that my code is what needs to determine if something is valid. That is, apparently this code is in the controller and is doing the checks.

Ok, so then the validator needs to be queried: given a coin with such and such characteristics, should I reject it or keep it?

Actually, now I see that there is a validator (reject/keep decision) and an identifier (which coin is it). 

The identifier should be given a weight and a size. Ultimately it would be nice to have these pieces of data provided in a file so it is easy to update the vending machine with new valid coin types, such as when the mint decides to offer special kinds of coins. What if the buffalo nickel is reintroduced? In the meantime, I am going to look up the weights of the coins and hardcode them in. Oh, hey, https://www.usmint.gov/learn/coin-and-medal-programs/coin-specifications is handy.

I realize the size isn't in one dimension. There is the diameter of the coin as well as the thickness of the coin. 

And I know from experience that using ints is better than using floats, even if floats are an intuitive choice. Checking equality of floats is awkward, and so the ints will need to be multiplied in a standard way. So, if a quarter is 5.670 grams, it can be represented as 5670. 

The story mentions only weight and size, although real vending machines also use electromagnets to identify the metal types. While I won't work on it, I can imagine such a feature being needed in the future. So, I'm thinking about the open-closed principle and wondering if there is a way to design my identifier to take a collection of objects that each consider some criteria about the coin in question and then queries each object to determine what they all think it is. So, a WeightIdentifier and a SizeIdentifier today, but tomorrow there might be a MetalContentIdentifier. If they all agree, then it is the coin they all say it is, but if they don't agree, it's an invalid coin. Maybe it is overkill to design it that way now, but it's good to keep in mind, and it should be easy to refactor to such a solution later.

Instead of coin validator, I've decided to call it a coin accepter. 

My next test needed a way to add a coin, and I deciced to create a data structure for it. Which drove the need for a CoinCandidate struct. And like my Cents typedef, I am thinking that it might make sense to create typedefs for the weight, diameter, and thickness. I'll worry about refactoring once this test passes, although I already refactored to move the weight, diameter, and thickness enums into their own header so I can use them directly in this test.

For this test, I'm making it pass in the simplest way possible, as per TDD As If You Mean It. I find it is helpful to test-drive in this way, instead of assuming my higher-level design is accurate. Sometimes, I find that a completely different approach appears and works pretty well if I let the tests drive the design like they are supposed to. 

Ultimately, my coin accepter should use the coin identifier to recognize the different coins. My inclination would be to mock out the identifier, inject it into accepter's constructor, and ensure that each class is tested independently. On the other hand, the behavior of the accepter shouldn't rely on implementation details (which are already tested in its own class). The benefit of the former is that if something is broken, the tests will tell me exactly where it went wrong, whereas the advantage of the latter is that it should result in less brittle code. It feels awkward to have two separate unit tests for two separate classes that say "given these quarter characteristics, ensure that it thinks it is a quarter", but they are operating on two different concepts. One is about the coin itself, and the other is about the result of knowing it is a specific coin. 

Now we're using the identifier, but the values are hardcoded. I can already see replacing my switch statement with a map, and providing constants for the Cents. And eventually I would like to be able to keep a collection of CoinTypes, but they aren't really needed until the story Return Coins. Until then, a running total works just fine.

Interestingly enough, we're now adding the ability to give back a rejected coin, which means we need a place to put it. Currently we're rejecting a single coin at a time, but since I know I need to be able to provide multiple coins at a later time, I should use a collection of returned coins. YAGNI says I shouldn't, but in this case, I'll err on the side of "in software, you usually have none or many, never just one". 

Ok, we have a coin accepter doing what it needs to do to satisfy the story. Now we need the vending machine to display different things based on what coins we have in the machine. To start with, we show the default text. 

Now we need the coin accepter and the display to work together. I put the coins in the accepter, but the display tells me what is inside of it. I could have made separate unit tests for each expect, but putting multiple coins in and seeing them total up seemed like a fine thing for this one test. 

I like the symmetry of returning the default text or returning a calculated result, so amountUI() was created. This function is slightly complicated since we need to show the output as both dollars and cents, while Cents is an int. Should there be more tests driving it? I think so, although I hate having a temporary implementation here that forgets that dollars are needed. So, I updated the test to add up to more than $1, even though it makes the test a big of a bigger task to implement. If I run into trouble, I can always backtrack and start slower and with smaller steps. I've implemented a similar piece of functionality in a game I made in 2013 about selling candy in which I needed to represent money, so I have a working reference of my own.

I realize that this test might need to change to accomodate the Exact Change Only story later, but as I don't have a way to query if I have enough money to make change, I'll worry about it later.

I'd like to be able to actually interact with this program, so let's create an App to manage input. It would make for a good demo for the implemented feature.

Technically I added VendingMachineApp.h/.cpp when I initially wrote the lines in the test that needed them, but I didn't want to make such tiny commits to illustrate it.

Ah, ha! I've uncovered a defect! Apparently when I have only 5 cents on the machine, it outputs as 50 cents instead. My test for the app is failing because I had a test gap in my display code.

Ok, now we have a test that reproduces the defect. Now to fix it.

Note, I could have commented out the failing app test, but I decided not to as it wasn't adding much noise, and I think it would be satisfying to have both tests pass with the same fix.

Now to run the demo:

$ ./KataForPT-bin 
INSERT COIN
q
0.25
q
0.50
d
0.60
n
0.65
p
0.65
p
0.65
p
0.65
r
Returned: rejected coin, rejected coin, rejected coin
d
0.75

Works great!
